"""–°–µ—Ä–≤–∏—Å –¥–ª—è —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π"""
import re
import logging
from typing import Optional, Dict, Tuple, Union
from pathlib import Path
from loguru import logger

logger = logging.getLogger(__name__)

# –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏—è (–±–∞–Ω–∫–∏, –ø–ª–∞—Ç–µ–∂–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã, —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω—ã–µ –∫–æ–º–ø–∞–Ω–∏–∏)
EXCLUDE_KEYWORDS = [
    '–±–∞–Ω–∫', '—Å–±–µ—Ä–±–∞–Ω–∫', '–∞–ª—å—Ñ–∞', '—Ç–∏–Ω—å–∫–æ—Ñ—Ñ', '–≤—Ç–±', '–≥–∞–∑–ø—Ä–æ–º–±–∞–Ω–∫',
    '–±–∞–Ω–∫ —Ç–æ—á–∫–∞', '—Ç–æ—á–∫–∞ –±–∞–Ω–∫', '—Ç–æ—á–∫–∞',
    '—è–Ω–¥–µ–∫—Å', 'qiwi', 'webmoney', 'visa', 'mastercard', '–º–∏—Ä',
    '–ø–ª–∞—Ç–µ–∂', '–ø–ª–∞—Ç–µ–∂–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞', '—ç–∫–≤–∞–π—Ä–∏–Ω–≥', '—Ä–∞—Å—á–µ—Ç–Ω—ã–π —Å—á–µ—Ç',
    '—Ä/—Å', '—Ä/—Å—á–µ—Ç', '—Ä–∞—Å—á–µ—Ç–Ω—ã–π —Å—á–µ—Ç',
    '–¥–µ–ª–æ–≤—ã–µ –ª–∏–Ω–∏–∏', '—Ç–∫ –¥–µ–ª–æ–≤—ã–µ –ª–∏–Ω–∏–∏', '—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è',
    '–±–∞–∑–∏—Å –ø–æ—Å—Ç–∞–≤–∫–∏', 'fca', '–∏–Ω–∫–æ—Ç–µ—Ä–º—Å'
]

# –ú–∞—Ä–∫–µ—Ä—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞
SUPPLIER_MARKERS = [
    '–ø–æ—Å—Ç–∞–≤—â–∏–∫', '–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å', '–ø—Ä–æ–¥–∞–≤–µ—Ü', '–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è',
    '–∫–æ–º–ø–∞–Ω–∏—è', '—Ñ–∏—Ä–º–∞', '–ø–æ–¥—Ä—è–¥—á–∏–∫', '–∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç'
]

# –ú–∞—Ä–∫–µ—Ä—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å—É–º–º—ã
TOTAL_AMOUNT_MARKERS = [
    '–∏—Ç–æ–≥–æ —Å –Ω–¥—Å', '–∏—Ç–æ–≥–æ', '—Å—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ', '–∫ –æ–ø–ª–∞—Ç–µ',
    '–≤—Å–µ–≥–æ –∫ –æ–ø–ª–∞—Ç–µ', '–∏—Ç–æ–≥–æ–≤–∞—è —Å—É–º–º–∞', '—Å—É–º–º–∞ –≤—Å–µ–≥–æ',
    '–∏—Ç–æ–≥–æ:', '–∫ —É–ø–ª–∞—Ç–µ', '—Å—É–º–º–∞:', '—Å—Ç–æ–∏–º–æ—Å—Ç—å:',
    '–≤—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π', '–Ω–∞ —Å—É–º–º—É', '–≤—Å–µ–≥–æ:'
]


def extract_supplier_name_improved(text: str) -> Optional[str]:
    """
    –£–ª—É—á—à–µ–Ω–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞ –ö–ü
    
    –£—á–∏—Ç—ã–≤–∞–µ—Ç:
    - –ü–æ–∏—Å–∫ –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º (–ü–æ—Å—Ç–∞–≤—â–∏–∫, –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å, –ü—Ä–æ–¥–∞–≤–µ—Ü)
    - –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –±–∞–Ω–∫–æ–≤ –∏ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º
    - –ü–æ–∏—Å–∫ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ–æ—Ä–º (–û–û–û, –û–ê–û, –ó–ê–û, –ò–ü, –ü–ê–û)
    - –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫ —Å "–ë–∞–∑–∏—Å –ø–æ—Å—Ç–∞–≤–∫–∏", "FCA" –∏ —Ç.–¥.
    """
    if not text:
        return None
    
    lines = text.split('\n')
    candidates = []  # –°–ø–∏—Å–æ–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
    
    # –ò—â–µ–º –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º –≤ –ø–µ—Ä–≤—ã—Ö 50 —Å—Ç—Ä–æ–∫–∞—Ö
    for i, line in enumerate(lines[:50]):
        line_lower = line.lower().strip()
        line_original = line.strip()
        
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –∏—Å–∫–ª—é—á–∞—é—â–∏–º–∏ –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏
        skip_line = False
        for exclude in ['–±–∞–∑–∏—Å –ø–æ—Å—Ç–∞–≤–∫–∏', 'fca', '–∏–Ω–∫–æ—Ç–µ—Ä–º—Å', '–¥–æ—Å—Ç–∞–≤–∫–∞ –≤ —Ç–∫', '—Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è']:
            if exclude in line_lower:
                skip_line = True
                break
        if skip_line:
            continue
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–∞—Ä–∫–µ—Ä–æ–≤ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞
        for marker in SUPPLIER_MARKERS:
            if marker in line_lower:
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ –º–∞—Ä–∫–µ—Ä–∞
                if ':' in line_original:
                    # –ï—Å–ª–∏ –º–∞—Ä–∫–µ—Ä –≤ —Ç–æ–π –∂–µ —Å—Ç—Ä–æ–∫–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–ü–æ—Å—Ç–∞–≤—â–∏–∫: –û–û–û –ö–æ–º–ø–∞–Ω–∏—è")
                    parts = line_original.split(':', 1)
                    if len(parts) > 1:
                        supplier = parts[1].strip()
                        if _is_valid_supplier_name(supplier):
                            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –º–∞—Ä–∫–µ—Ä –≤ —Ç–æ–π –∂–µ —Å—Ç—Ä–æ–∫–µ
                            candidates.append((supplier[:200], 1))
                else:
                    # –ï—Å–ª–∏ –º–∞—Ä–∫–µ—Ä –æ—Ç–¥–µ–ª—å–Ω–æ, –±–µ—Ä–µ–º —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–æ–∫—É
                    if i + 1 < len(lines):
                        supplier = lines[i + 1].strip()
                        if _is_valid_supplier_name(supplier):
                            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –º–∞—Ä–∫–µ—Ä –æ—Ç–¥–µ–ª—å–Ω–æ
                            candidates.append((supplier[:200], 2))
        
        # –¢–∞–∫–∂–µ –∏—â–µ–º –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã –Ω–∞–ø—Ä—è–º—É—é (–Ω–∏–∑–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
        if _is_valid_supplier_name(line_original):
            candidates.append((line_original[:200], 3))
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ —Å –Ω–∞–∏–≤—ã—Å—à–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º (–º–µ–Ω—å—à–∏–π –Ω–æ–º–µ—Ä = –≤—ã—à–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    if candidates:
        candidates.sort(key=lambda x: x[1])
        return candidates[0][0]
    
    return None


def _is_valid_supplier_name(name: str) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –≤–∞–ª–∏–¥–Ω—ã–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞
    """
    if not name or len(name) < 3:
        return False
    
    name_lower = name.lower().strip()
    
    # –ù–µ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø—Ä–æ—Å—Ç–æ "–ø–æ—Å—Ç–∞–≤—â–∏–∫", "–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å" –∏ —Ç.–¥.
    if name_lower in ['–ø–æ—Å—Ç–∞–≤—â–∏–∫', '–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å', '–ø—Ä–æ–¥–∞–≤–µ—Ü', '–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è', '–∫–æ–º–ø–∞–Ω–∏—è', '—Ñ–∏—Ä–º–∞']:
        return False
    
    # –ù–µ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∏—Å–∫–ª—é—á–∞—é—â–∏–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (–ø—Ä–æ–≤–µ—Ä—è–µ–º –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å)
    for exclude in EXCLUDE_KEYWORDS:
        if exclude in name_lower:
            return False
    
    # –î–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—É—é —Ñ–æ—Ä–º—É
    org_forms = ['–æ–æ–æ', '–æ–∞–æ', '–∑–∞–æ', '–ø–∞–æ', '–∏–ø', '–∞–æ', '–øao']
    has_org_form = any(form in name_lower for form in org_forms)
    
    if not has_org_form:
        return False
    
    # –ù–µ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–π (–ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏)
    if len(name.strip()) < 5:
        return False
    
    # –ù–µ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø—Ä–æ—Å—Ç–æ –∏–∫–æ–Ω–∫–æ–π/—Å–∏–º–≤–æ–ª–∞–º–∏
    if re.match(r'^[\W\d]+$', name):
        return False
    
    # –ù–µ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å –º–∞—Ä–∫–µ—Ä–æ–≤ –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å:" –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è)
    if ':' in name and len(name.split(':', 1)[1].strip()) < 3:
        return False
    
    return True


def _parse_amount_in_words(text: str) -> Optional[float]:
    """
    –ü–∞—Ä—Å–∏—Ç —Å—É–º–º—É, –Ω–∞–ø–∏—Å–∞–Ω–Ω—É—é –ø—Ä–æ–ø–∏—Å—å—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–î–≤–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –≤–æ—Å–µ–º—å—Å–æ—Ç —Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å —Ä—É–±–ª–µ–π 65 –∫–æ–ø–µ–µ–∫")
    """
    logger.info(f"üîç Attempting to parse amount in words from text (length: {len(text)} chars)")
    # –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    text_preview = text[:500] if len(text) > 500 else text
    logger.debug(f"Text preview: {text_preview}...")
    text_lower = text.lower()
    
    # –°–ª–æ–≤–∞—Ä—å –¥–ª—è —á–∏—Å–µ–ª
    numbers = {
        '–Ω–æ–ª—å': 0, '–æ–¥–∏–Ω': 1, '–æ–¥–Ω–∞': 1, '–¥–≤–∞': 2, '–¥–≤–µ': 2, '—Ç—Ä–∏': 3, '—á–µ—Ç—ã—Ä–µ': 4, '–ø—è—Ç—å': 5,
        '—à–µ—Å—Ç—å': 6, '—Å–µ–º—å': 7, '–≤–æ—Å–µ–º—å': 8, '–¥–µ–≤—è—Ç—å': 9, '–¥–µ—Å—è—Ç—å': 10,
        '–æ–¥–∏–Ω–Ω–∞–¥—Ü–∞—Ç—å': 11, '–¥–≤–µ–Ω–∞–¥—Ü–∞—Ç—å': 12, '—Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å': 13, '—á–µ—Ç—ã—Ä–Ω–∞–¥—Ü–∞—Ç—å': 14,
        '–ø—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 15, '—à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç—å': 16, '—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 17, '–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å': 18,
        '–¥–µ–≤—è—Ç–Ω–∞–¥—Ü–∞—Ç—å': 19, '–¥–≤–∞–¥—Ü–∞—Ç—å': 20, '—Ç—Ä–∏–¥—Ü–∞—Ç—å': 30, '—Å–æ—Ä–æ–∫': 40,
        '–ø—è—Ç—å–¥–µ—Å—è—Ç': 50, '—à–µ—Å—Ç—å–¥–µ—Å—è—Ç': 60, '—Å–µ–º—å–¥–µ—Å—è—Ç': 70, '–≤–æ—Å–µ–º—å–¥–µ—Å—è—Ç': 80,
        '–¥–µ–≤—è–Ω–æ—Å—Ç–æ': 90, '—Å—Ç–æ': 100, '–¥–≤–µ—Å—Ç–∏': 200, '—Ç—Ä–∏—Å—Ç–∞': 300, '—á–µ—Ç—ã—Ä–µ—Å—Ç–∞': 400,
        '–ø—è—Ç—å—Å–æ—Ç': 500, '—à–µ—Å—Ç—å—Å–æ—Ç': 600, '—Å–µ–º—å—Å–æ—Ç': 700, '–≤–æ—Å–µ–º—å—Å–æ—Ç': 800,
        '–¥–µ–≤—è—Ç—å—Å–æ—Ç': 900
    }
    
    multipliers = {
        '—Ç—ã—Å—è—á': 1000, '—Ç—ã—Å—è—á–∞': 1000, '—Ç—ã—Å—è—á–∏': 1000,
        '–º–∏–ª–ª–∏–æ–Ω': 1000000, '–º–∏–ª–ª–∏–æ–Ω–∞': 1000000, '–º–∏–ª–ª–∏–æ–Ω–æ–≤': 1000000,
        '–º–∏–ª–ª–∏–∞—Ä–¥': 1000000000, '–º–∏–ª–ª–∏–∞—Ä–¥–∞': 1000000000, '–º–∏–ª–ª–∏–∞—Ä–¥–æ–≤': 1000000000
    }
    
    # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω: —á–∏—Å–ª–æ –ø—Ä–æ–ø–∏—Å—å—é + "—Ä—É–±–ª–µ–π" + –∫–æ–ø–µ–π–∫–∏
    # –ü—Ä–∏–º–µ—Ä: "–î–≤–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –≤–æ—Å–µ–º—å—Å–æ—Ç —Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å —Ä—É–±–ª–µ–π 65 –∫–æ–ø–µ–µ–∫"
    # –ü—Ä–∏–º–µ—Ä: "–í–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –¥–µ–≤—è—Ç—å—Å–æ—Ç —Ç—Ä–∏–¥—Ü–∞—Ç—å –¥–≤–∞ —Ä—É–±–ª—è 49 –∫–æ–ø–µ–µ–∫"
    # –ë–æ–ª–µ–µ –≥–∏–±–∫–∏–π –ø–∞—Ç—Ç–µ—Ä–Ω, –∫–æ—Ç–æ—Ä—ã–π –∏—â–µ—Ç —Å—É–º–º—É –ø—Ä–æ–ø–∏—Å—å—é –¥–æ —Å–ª–æ–≤–∞ "—Ä—É–±–ª–µ–π"
    
    # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º —Å –∫–æ–ø–µ–π–∫–∞–º–∏ (–±–æ–ª–µ–µ —Ç–æ—á–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω)
    # –ò—â–µ–º: —Å–ª–æ–≤–∞ (–º–∏–Ω–∏–º—É–º 3 —Å–ª–æ–≤–∞ –¥–ª—è —Å–æ—Å—Ç–∞–≤–Ω—ã—Ö —á–∏—Å–µ–ª) + "—Ä—É–±–ª–µ–π"/"—Ä—É–±–ª—è"/"—Ä—É–±–ª—å" + —Ü–∏—Ñ—Ä—ã + "–∫–æ–ø–µ–µ–∫"/"–∫–æ–ø–µ–π–∫–∏"/"–∫–æ–ø–µ–π–∫–∞"
    # –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω: –∏—â–µ–º –±–æ–ª–µ–µ –≥–∏–±–∫–æ, —É—á–∏—Ç—ã–≤–∞—è –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏ –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è
    
    # –ë–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ - –∏—â–µ–º –ª—é–±—É—é —Å—Ç—Ä–æ–∫—É —Å —á–∏—Å–ª–∞–º–∏ –ø—Ä–æ–ø–∏—Å—å—é + "—Ä—É–±–ª–µ–π" + –∫–æ–ø–µ–π–∫–∏
    # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    patterns = [
        # –ü–∞—Ç—Ç–µ—Ä–Ω 1: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π - –º–∏–Ω–∏–º—É–º 2 —Å–ª–æ–≤–∞ (–¥–ª—è "–î–≤–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á")
        r'([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+){1,}(?:\s+—Ç—ã—Å—è—á[–∞–∏]?)?(?:\s+[–∞-—è—ë]+)*\s+—Ä—É–±–ª[–µ–π—è]?)\s+(\d{1,2})\s+–∫–æ–ø–µ[–µ–∫–π]',
        # –ü–∞—Ç—Ç–µ—Ä–Ω 2: —Å –∑–Ω–∞–∫–∞–º–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –º–µ–∂–¥—É "—Ä—É–±–ª–µ–π" –∏ –∫–æ–ø–µ–π–∫–∞–º–∏
        r'([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+){1,}(?:\s+—Ç—ã—Å—è—á[–∞–∏]?)?(?:\s+[–∞-—è—ë]+)*\s+—Ä—É–±–ª[–µ–π—è]?)[\s.,:;]+(\d{1,2})\s+–∫–æ–ø–µ[–µ–∫–π]',
        # –ü–∞—Ç—Ç–µ—Ä–Ω 3: –æ—á–µ–Ω—å –≥–∏–±–∫–∏–π - –ª—é–±–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–ª–æ–≤ –¥–æ "—Ä—É–±–ª–µ–π"
        r'([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+){0,}\s+—Ä—É–±–ª[–µ–π—è]?)[\s.,:;]+(\d{1,2})\s+–∫–æ–ø–µ[–µ–∫–π]',
        # –ü–∞—Ç—Ç–µ—Ä–Ω 4: —Å —É—á–µ—Ç–æ–º –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –ø–µ—Ä–µ–Ω–æ—Å–æ–≤ —Å—Ç—Ä–æ–∫
        r'([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+){1,}(?:\s+—Ç—ã—Å—è—á[–∞–∏]?)?(?:\s+[–∞-—è—ë]+)*\s+—Ä—É–±–ª[–µ–π—è]?)[\s\n.,:;]+(\d{1,2})\s+–∫–æ–ø–µ[–µ–∫–π]',
        # –ü–∞—Ç—Ç–µ—Ä–Ω 5: –∏—â–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ "–í–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –¥–µ–≤—è—Ç—å—Å–æ—Ç —Ç—Ä–∏–¥—Ü–∞—Ç—å –¥–≤–∞ —Ä—É–±–ª—è 49 –∫–æ–ø–µ–µ–∫"
        r'(–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å\s+—Ç—ã—Å—è—á\s+–¥–µ–≤—è—Ç—å—Å–æ—Ç\s+—Ç—Ä–∏–¥—Ü–∞—Ç—å\s+–¥–≤–∞\s+—Ä—É–±–ª—è)\s+(\d{1,2})\s+–∫–æ–ø–µ[–µ–∫–π]',
    ]
    
    match = None
    for i, pattern in enumerate(patterns, 1):
        match = re.search(pattern, text_lower, re.IGNORECASE | re.MULTILINE)
        if match:
            logger.info(f"‚úÖ Pattern {i} (with kopecks) matched: '{match.group(0)[:150]}...'")
            break
        else:
            logger.debug(f"Pattern {i} (with kopecks): no match")
    
    kopecks = 0
    if match:
        words_part = match.group(1)
        try:
            kopecks = int(match.group(2))
            logger.debug(f"Found amount in words with kopecks: '{words_part}' + {kopecks} kopecks")
        except (ValueError, IndexError):
            kopecks = 0
            logger.warning(f"Failed to parse kopecks from match: {match.groups()}")
    else:
        # –ü—Ä–æ–±—É–µ–º –±–µ–∑ –∫–æ–ø–µ–µ–∫ (–±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫)
        patterns_no_kopecks = [
            # –ü–∞—Ç—Ç–µ—Ä–Ω 1: –º–∏–Ω–∏–º—É–º 2 —Å–ª–æ–≤–∞ (–¥–ª—è "–î–≤–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á")
            r'([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+){1,}(?:\s+—Ç—ã—Å—è—á[–∞–∏]?)?(?:\s+[–∞-—è—ë]+)*\s+—Ä—É–±–ª[–µ–π—è]?)',
            # –ü–∞—Ç—Ç–µ—Ä–Ω 2: –æ—á–µ–Ω—å –≥–∏–±–∫–∏–π - –ª—é–±–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            r'([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+){0,}\s+—Ä—É–±–ª[–µ–π—è]?)',
            # –ü–∞—Ç—Ç–µ—Ä–Ω 3: –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ "–í–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –¥–µ–≤—è—Ç—å—Å–æ—Ç —Ç—Ä–∏–¥—Ü–∞—Ç—å –¥–≤–∞ —Ä—É–±–ª—è"
            r'(–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å\s+—Ç—ã—Å—è—á\s+–¥–µ–≤—è—Ç—å—Å–æ—Ç\s+—Ç—Ä–∏–¥—Ü–∞—Ç—å\s+–¥–≤–∞\s+—Ä—É–±–ª—è)',
        ]
        
        for i, pattern in enumerate(patterns_no_kopecks, 1):
            match = re.search(pattern, text_lower, re.IGNORECASE | re.MULTILINE)
            if match:
                logger.info(f"‚úÖ Pattern {i} (without kopecks) matched: '{match.group(0)[:150]}...'")
                break
            else:
                logger.debug(f"Pattern {i} (without kopecks): no match")
        
        if not match:
            logger.warning("‚ùå No amount in words pattern matched at all")
            # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ª—é–±—É—é —Å—Ç—Ä–æ–∫—É —Å "—Ä—É–±–ª–µ–π" –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            debug_matches = list(re.finditer(r'[–∞-—è—ë]+\s+—Ä—É–±–ª[–µ–π—è]?', text_lower))
            if debug_matches:
                logger.info(f"Debug: found {len(debug_matches)} matches with '—Ä—É–±–ª–µ–π' in text:")
                for j, debug_match in enumerate(debug_matches[:5], 1):  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 5
                    context_start = max(0, debug_match.start() - 100)
                    context_end = min(len(text_lower), debug_match.end() + 100)
                    context = text_lower[context_start:context_end]
                    logger.info(f"  Match {j}: ...{context}...")
            return None
        
        words_part = match.group(1)
        logger.info(f"Found amount in words without kopecks: '{words_part}'")
    
    # –ü–∞—Ä—Å–∏–º —Å–ª–æ–≤–∞ - —É–ª—É—á—à–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Å–æ—Å—Ç–∞–≤–Ω—ã—Ö —á–∏—Å–µ–ª
    words = words_part.split()
    total = 0
    current = 0
    
    for word in words:
        word = word.strip('.,;:!?()"')
        
        if word in numbers:
            current += numbers[word]
        elif word in multipliers:
            multiplier_value = multipliers[word]
            if current == 0:
                current = 1
            # –£–º–Ω–æ–∂–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞ –º–Ω–æ–∂–∏—Ç–µ–ª—å –∏ –¥–æ–±–∞–≤–ª—è–µ–º –∫ –æ–±—â–µ–π —Å—É–º–º–µ
            total += current * multiplier_value
            current = 0
        elif word in ['—Ä—É–±–ª–µ–π', '—Ä—É–±–ª—è', '—Ä—É–±–ª—å']:
            # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ
            total += current
            current = 0  # –û–±–Ω—É–ª—è–µ–º current, —á—Ç–æ–±—ã –Ω–µ –¥–æ–±–∞–≤–∏—Ç—å –µ–≥–æ —Å–Ω–æ–≤–∞ –ø–æ—Å–ª–µ —Ü–∏–∫–ª–∞
            break
    
    # –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–±–µ–∑ —Å–ª–æ–≤–∞ "—Ä—É–±–ª–µ–π")
    # –≠—Ç–æ –Ω—É–∂–Ω–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º—ã –Ω–µ –≤—Å—Ç—Ä–µ—Ç–∏–ª–∏ "—Ä—É–±–ª—è" –≤ —Ü–∏–∫–ª–µ
    if current > 0:
        total += current
    
    # –õ–æ–≥–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    if total > 0:
        result = total + (kopecks / 100)
        logger.info(f"Successfully parsed amount in words: '{words_part}' -> {total} + {kopecks} kopecks = {result}")
        return result
    else:
        logger.warning(f"Failed to parse amount from words: '{words_part}' (total=0)")
    
    return None


async def _extract_amount_in_words_llm(text: str) -> Optional[float]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—É–º–º—É –ø—Ä–æ–ø–∏—Å—å—é —Å –ø–æ–º–æ—â—å—é LLM (fallback)
    """
    try:
        from services.ai.perplexity import ask_perplexity
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞
        text_sample = text[:4000] if len(text) > 4000 else text
        
        prompt = f"""–í —Å–ª–µ–¥—É—é—â–µ–º —Ç–µ–∫—Å—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ (—Å—á–µ—Ç, –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ) –Ω–∞–π–¥–∏—Ç–µ –∏—Ç–æ–≥–æ–≤—É—é —Å—É–º–º—É, –Ω–∞–ø–∏—Å–∞–Ω–Ω—É—é –ø—Ä–æ–ø–∏—Å—å—é.

–¢–µ–∫—Å—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞:
{text_sample}

–ù–∞–π–¥–∏ —Å—Ç—Ä–æ–∫—É, –≥–¥–µ —É–∫–∞–∑–∞–Ω–∞ –∏—Ç–æ–≥–æ–≤–∞—è —Å—É–º–º–∞ –ø—Ä–æ–ø–∏—Å—å—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–î–≤–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –≤–æ—Å–µ–º—å—Å–æ—Ç —Ç—Ä–∏–Ω–∞–¥—Ü–∞—Ç—å —Ä—É–±–ª–µ–π 65 –∫–æ–ø–µ–µ–∫" –∏–ª–∏ "–í–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –¥–µ–≤—è—Ç—å—Å–æ—Ç —Ç—Ä–∏–¥—Ü–∞—Ç—å –¥–≤–∞ —Ä—É–±–ª—è 49 –∫–æ–ø–µ–µ–∫").

–û—Ç–≤–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å –¢–û–õ–¨–ö–û —á–∏—Å–ª–æ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –ß–ò–°–õ–û.–ö–û–ü–ï–ô–ö–ò
–ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ —Å—É–º–º–∞ "–í–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å —Ç—ã—Å—è—á –¥–µ–≤—è—Ç—å—Å–æ—Ç —Ç—Ä–∏–¥—Ü–∞—Ç—å –¥–≤–∞ —Ä—É–±–ª—è 49 –∫–æ–ø–µ–µ–∫", –æ—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å: 18932.49

–ï—Å–ª–∏ —Å—É–º–º–∞ –ø—Ä–æ–ø–∏—Å—å—é –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –æ—Ç–≤–µ—Ç—å: –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"""
        
        response = await ask_perplexity(
            [{"role": "user", "content": prompt}],
            model=None,
            temperature=0.1,
            max_tokens=100
        )
        
        # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç - –∏—â–µ–º —á–∏—Å–ª–æ
        import re
        # –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥: –∏—â–µ–º —á–∏—Å–ª–æ –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö
        # –£–¥–∞–ª—è–µ–º –∑–≤–µ–∑–¥–æ—á–∫–∏ –∏ –¥—Ä—É–≥–∏–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É—é—â–∏–µ —Å–∏–º–≤–æ–ª—ã
        response_clean = response.replace('*', '').replace('**', '').strip()
        
        # –ò—â–µ–º —á–∏—Å–ª–æ —Å —Ç–æ—á–∫–æ–π –∏–ª–∏ –∑–∞–ø—è—Ç–æ–π (–º–æ–∂–µ—Ç –±—ã—Ç—å —Å –ø—Ä–æ–±–µ–ª–∞–º–∏)
        # –ü–∞—Ç—Ç–µ—Ä–Ω: —á–∏—Å–ª–æ —Å –≤–æ–∑–º–æ–∂–Ω—ã–º–∏ –ø—Ä–æ–±–µ–ª–∞–º–∏, —Ç–æ—á–∫–æ–π/–∑–∞–ø—è—Ç–æ–π –∏ –∫–æ–ø–µ–π–∫–∞–º–∏
        patterns = [
            r'(\d{1,3}(?:\s?\d{3})*(?:[.,]\d{1,2})?)',  # –° –ø—Ä–æ–±–µ–ª–∞–º–∏: "11 568.00"
            r'(\d{4,10}(?:[.,]\d{1,2})?)',  # –ë–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤: "11568.00"
            r'(\d+[.,]\d{2})',  # –ü—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ —Å –∫–æ–ø–µ–π–∫–∞–º–∏: "11568.00"
            r'(\d+)',  # –ü—Ä–æ—Å—Ç–æ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (–ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–∞—Ä–∏–∞–Ω—Ç)
        ]
        
        for pattern in patterns:
            number_match = re.search(pattern, response_clean.replace(' ', ''))
            if number_match:
                amount_str = number_match.group(1).replace(',', '.').replace(' ', '')
                try:
                    amount = float(amount_str)
                    if _is_valid_amount(amount):
                        logger.info(f"‚úÖ LLM extracted amount: {amount} (from pattern: {pattern})")
                        return amount
                except ValueError:
                    continue
        
        logger.warning(f"‚ùå LLM failed to extract amount. Response: {response}")
        return None
        
    except Exception as e:
        logger.error(f"Error extracting amount in words via LLM: {e}", exc_info=True)
        return None


async def extract_total_amount_improved(text: str) -> Optional[float]:
    """
    –£–ª—É—á—à–µ–Ω–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏—Ç–æ–≥–æ–≤–æ–π —Å—É–º–º—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞ –ö–ü
    
    –ò—â–µ—Ç:
    - –°—É–º–º—É –ø—Ä–æ–ø–∏—Å—å—é (–≤—ã—Å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    - –í —Å—Ç–æ–ª–±—Ü–µ "–ò—Ç–æ–≥–æ —Å –ù–î–°"
    - –í —Å—Ç—Ä–æ–∫–∞—Ö —Å –º–∞—Ä–∫–µ—Ä–∞–º–∏ —Å—É–º–º—ã
    - –ò—Å–∫–ª—é—á–∞–µ—Ç —Ä–∞—Å—á–µ—Ç–Ω—ã–µ —Å—á–µ—Ç–∞, –ò–ù–ù, –ö–ü–ü, –ë–ò–ö
    """
    if not text:
        return None
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ò—â–µ–º —Å—É–º–º—É –ø—Ä–æ–ø–∏—Å—å—é (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π —Å–ø–æ—Å–æ–± - –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    # –ò—â–µ–º –≤–æ –≤—Å–µ–º —Ç–µ–∫—Å—Ç–µ, –Ω–µ —Ç–æ–ª—å–∫–æ –≤ –Ω–∞—á–∞–ª–µ
    logger.info(f"üí∞ Extracting total amount from text (length: {len(text)} chars)")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤ —Ç–µ–∫—Å—Ç–µ —Å–ª–æ–≤–∞, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å —Å—É–º–º–æ–π –ø—Ä–æ–ø–∏—Å—å—é
    text_lower = text.lower()
    has_amount_keywords = any(keyword in text_lower for keyword in ['—Ä—É–±–ª–µ–π', '—Ä—É–±–ª—è', '—Ä—É–±–ª—å', '–∫–æ–ø–µ–µ–∫', '–∫–æ–ø–µ–π–∫–∏', '–∫–æ–ø–µ–π–∫–∞'])
    has_number_words = any(word in text_lower for word in ['—Ç—ã—Å—è—á', '–º–∏–ª–ª–∏–æ–Ω', '–≤–æ—Å–µ–º–Ω–∞–¥—Ü–∞—Ç—å', '–¥–µ–≤—è—Ç–Ω–∞–¥—Ü–∞—Ç—å', '–¥–≤–∞–¥—Ü–∞—Ç—å'])
    logger.info(f"Text contains '—Ä—É–±–ª–µ–π/—Ä—É–±–ª—è': {has_amount_keywords}, number words: {has_number_words}")
    
    # –ï—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–∏–∑–Ω–∞–∫–∏ —Å—É–º–º—ã –ø—Ä–æ–ø–∏—Å—å—é, –∏—â–µ–º –±–æ–ª–µ–µ —Ç—â–∞—Ç–µ–ª—å–Ω–æ
    if has_amount_keywords or has_number_words:
        logger.info("üîç Text contains amount-related keywords, searching for amount in words...")
        amount_in_words = _parse_amount_in_words(text)
        if amount_in_words and _is_valid_amount(amount_in_words):
            logger.info(f"‚úÖ Found amount in words: {amount_in_words} (absolute priority, returning immediately)")
            return amount_in_words
        else:
            logger.warning(f"‚ùå Amount in words not found or invalid. Attempted value: {amount_in_words}")
            # –ü—Ä–æ–±—É–µ–º LLM fallback –¥–ª—è —Å—É–º–º—ã –ø—Ä–æ–ø–∏—Å—å—é
            logger.info("ü§ñ Trying LLM fallback to extract amount in words...")
            amount_llm = await _extract_amount_in_words_llm(text)
            if amount_llm and _is_valid_amount(amount_llm):
                logger.info(f"‚úÖ Found amount in words via LLM: {amount_llm}")
                return amount_llm
            else:
                logger.warning(f"‚ùå LLM also failed to extract amount in words. Attempted value: {amount_llm}")
    else:
        logger.warning("‚ö†Ô∏è Text does not contain amount-related keywords, skipping amount in words search")
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ò—â–µ–º –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º —Å—É–º–º—ã
    logger.info("üîç Searching for amount by markers...")
    lines = text.split('\n')
    found_amounts = []
    
    for i, line in enumerate(lines):
        line_lower = line.lower()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–∞—Ä–∫–µ—Ä–æ–≤ —Å—É–º–º—ã
        for marker in TOTAL_AMOUNT_MARKERS:
            if marker in line_lower:
                logger.debug(f"Found marker '{marker}' in line {i}: {line[:100]}...")
                # –î–ª—è –º–∞—Ä–∫–µ—Ä–æ–≤ "–Ω–∞ —Å—É–º–º—É", "—Å—É–º–º–∞:" –∏ —Ç.–¥. –∏—â–µ–º —Å—É–º–º—É –ø–æ—Å–ª–µ –º–∞—Ä–∫–µ—Ä–∞
                if '–Ω–∞ —Å—É–º–º—É' in line_lower or '—Å—É–º–º–∞:' in line_lower or '—Å—É–º–º–∞ ' in line_lower:
                    # –ò—â–µ–º —Å—É–º–º—É –ø–æ—Å–ª–µ –º–∞—Ä–∫–µ—Ä–∞ –≤ —Ç–æ–π –∂–µ —Å—Ç—Ä–æ–∫–µ
                    marker_pos = line_lower.find(marker)
                    if marker_pos >= 0:
                        # –ë–µ—Ä–µ–º —á–∞—Å—Ç—å —Å—Ç—Ä–æ–∫–∏ –ø–æ—Å–ª–µ –º–∞—Ä–∫–µ—Ä–∞
                        after_marker = line[marker_pos + len(marker):]
                        amount = _extract_amount_from_line_safe(after_marker)
                        if amount and _is_valid_amount(amount):
                            logger.info(f"üí∞ Found amount by marker '{marker}': {amount} (line {i})")
                            found_amounts.append((amount, 1, i))  # –í—ã—Å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
                            continue
                
                # –î–ª—è –¥—Ä—É–≥–∏—Ö –º–∞—Ä–∫–µ—Ä–æ–≤ –∏—â–µ–º —á–∏—Å–ª–æ –≤ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ –∏–ª–∏ —Å–ª–µ–¥—É—é—â–µ–π
                amount = _extract_amount_from_line_safe(line)
                if amount and _is_valid_amount(amount):
                    logger.info(f"üí∞ Found amount by marker '{marker}': {amount} (line {i})")
                    found_amounts.append((amount, 1, i))  # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1 = –Ω–∞–π–¥–µ–Ω–æ –ø–æ –º–∞—Ä–∫–µ—Ä—É –≤ —Å—Ç—Ä–æ–∫–µ
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–æ–∫—É
                if i + 1 < len(lines):
                    amount = _extract_amount_from_line_safe(lines[i + 1])
                    if amount and _is_valid_amount(amount):
                        logger.info(f"üí∞ Found amount by marker '{marker}': {amount} (line {i+1})")
                        found_amounts.append((amount, 2, i))  # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2 = –Ω–∞–π–¥–µ–Ω–æ –ø–æ –º–∞—Ä–∫–µ—Ä—É –≤ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–µ
    
    # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é (–Ω–∞–∏–±–æ–ª–µ–µ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—É—é)
    if found_amounts:
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É (–º–µ–Ω—å—à–∏–π –Ω–æ–º–µ—Ä = –≤—ã—à–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç), –∑–∞—Ç–µ–º –ø–æ –ø–æ–∑–∏—Ü–∏–∏ –≤ —Ç–µ–∫—Å—Ç–µ
        found_amounts.sort(key=lambda x: (x[1], x[2]))
        selected_amount = found_amounts[0][0]
        logger.warning(f"‚ö†Ô∏è Using amount from markers: {selected_amount} (was not found in words)")
        return selected_amount
    
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º, –∏—â–µ–º —Å—É–º–º—ã –≤ —Ç–µ–∫—Å—Ç–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏
    # –ò—â–µ–º —Ç–æ–ª—å–∫–æ —Å—É–º–º—ã —Å —É–∫–∞–∑–∞–Ω–∏–µ–º –≤–∞–ª—é—Ç—ã –∏–ª–∏ —Ä—è–¥–æ–º —Å –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏
    logger.info("üîç Searching for amounts in text by patterns...")
    all_amounts = []
    amount_patterns = [
        r'(\d{1,3}(?:\s\d{3})+(?:[.,]\d{2})?)\s*(?:—Ä—É–±|‚ÇΩ|—Ä\.|—Ä—É–±–ª–µ–π)',
        r'(?:–∏—Ç–æ–≥–æ|—Å—É–º–º–∞|—Å—Ç–æ–∏–º–æ—Å—Ç—å|–∫ –æ–ø–ª–∞—Ç–µ|–≤—Å–µ–≥–æ)[:\s]+(\d{1,3}(?:\s\d{3})*(?:[.,]\d{2})?)',
    ]
    
    for pattern in amount_patterns:
        matches = re.finditer(pattern, text, re.IGNORECASE)
        for match in matches:
            amount_str = match.group(1).replace(' ', '').replace(',', '.')
            try:
                amount = float(amount_str)
                if _is_valid_amount(amount):
                    logger.debug(f"Found amount by pattern: {amount}")
                    all_amounts.append(amount)
            except ValueError:
                continue
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–∏–±–æ–ª—å—à—É—é —Å—É–º–º—É –∏–∑ –≤–∞–ª–∏–¥–Ω—ã—Ö (–Ω–æ –Ω–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à—É—é)
    if all_amounts:
        # –§–∏–ª—å—Ç—Ä—É–µ–º —Ä–∞–∑—É–º–Ω—ã–µ —Å—É–º–º—ã (–¥–æ 1 –º–∏–ª–ª–∏–∞—Ä–¥–∞ —Ä—É–±–ª–µ–π)
        valid_amounts = [a for a in all_amounts if a <= 1_000_000_000]
        if valid_amounts:
            selected_amount = max(valid_amounts)
            logger.warning(f"‚ö†Ô∏è Using max amount from patterns: {selected_amount} (was not found in words or by markers)")
            return selected_amount
    
    logger.error("‚ùå No valid amount found in text at all!")
    return None


def _extract_amount_from_line_safe(line: str) -> Optional[float]:
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—É–º–º—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏
    –ò—Å–∫–ª—é—á–∞–µ—Ç —Ä–∞—Å—á–µ—Ç–Ω—ã–µ —Å—á–µ—Ç–∞, –ò–ù–ù, –ö–ü–ü, –ë–ò–ö
    """
    # –ò—Å–∫–ª—é—á–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏ —Å—á–µ—Ç–æ–≤ –∏ —Ä–µ–∫–≤–∏–∑–∏—Ç–æ–≤
    line_lower = line.lower()
    exclude_keywords = [
        '—Ä/—Å', '—Ä/—Å—á–µ—Ç', '—Ä–∞—Å—á–µ—Ç–Ω—ã–π —Å—á–µ—Ç', '—Å—á–µ—Ç ‚Ññ',
        '–∏–Ω–Ω', '–∫–ø–ø', '–±–∏–∫', '–±–∞–Ω–∫', '–±–∞–Ω–∫–æ–≤—Å–∫–∏–µ —Ä–µ–∫–≤–∏–∑–∏—Ç—ã',
        '–∫–æ—Ä—Ä. —Å—á–µ—Ç', '–∫–æ—Ä—Ä–µ—Å–ø–æ–Ω–¥–µ–Ω—Ç—Å–∫–∏–π —Å—á–µ—Ç'
    ]
    
    for keyword in exclude_keywords:
        if keyword in line_lower:
            return None  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å —Ä–µ–∫–≤–∏–∑–∏—Ç–∞–º–∏
    
    # –ò—â–µ–º —á–∏—Å–ª–∞ —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏ —Ç—ã—Å—è—á –∏ –∫–æ–ø–µ–π–∫–∞–º–∏
    patterns = [
        r'(\d{1,3}(?:\s\d{3})+(?:[.,]\d{2})?)',  # –° –ø—Ä–æ–±–µ–ª–∞–º–∏: "20 813,65"
        r'(\d{1,3}(?:\d{3})+(?:[.,]\d{2})?)',    # –ë–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤: "20813.65"
        r'(\d{4,10}(?:[.,]\d{2})?)',             # –ß–∏—Å–ª–∞ –æ—Ç 1000 –¥–æ 10 —Ü–∏—Ñ—Ä —Å –∫–æ–ø–µ–π–∫–∞–º–∏
    ]
    
    for pattern in patterns:
        matches = re.finditer(pattern, line)
        for match in matches:
            amount_str = match.group(1).replace(' ', '').replace(',', '.')
            try:
                amount = float(amount_str)
                if _is_valid_amount(amount):
                    return amount
            except ValueError:
                continue
    
    return None


def _is_valid_amount(amount: float) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —á–∏—Å–ª–æ –≤–∞–ª–∏–¥–Ω–æ–π —Å—É–º–º–æ–π (–Ω–µ —Ä–∞—Å—á–µ—Ç–Ω—ã–π —Å—á–µ—Ç, –ò–ù–ù –∏ —Ç.–¥.)
    """
    # –ò—Å–∫–ª—é—á–∞–µ–º —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–µ —Å—É–º–º—ã (–º–µ–Ω—å—à–µ 100 —Ä—É–±)
    if amount < 100:
        return False
    
    # –ò—Å–∫–ª—é—á–∞–µ–º —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ —Å—É–º–º—ã (–±–æ–ª—å—à–µ 1 –º–∏–ª–ª–∏–∞—Ä–¥–∞ - –≤–µ—Ä–æ—è—Ç–Ω–æ –Ω–µ —Å—É–º–º–∞)
    if amount > 1_000_000_000:
        return False
    
    # –ò—Å–∫–ª—é—á–∞–µ–º —á–∏—Å–ª–∞ –±–µ–∑ –∫–æ–ø–µ–µ–∫, –∫–æ—Ç–æ—Ä—ã–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–µ (–≤–µ—Ä–æ—è—Ç–Ω–æ —Ä–∞—Å—á–µ—Ç–Ω—ã–π —Å—á–µ—Ç)
    # –†–∞—Å—á–µ—Ç–Ω—ã–π —Å—á–µ—Ç –æ–±—ã—á–Ω–æ 20 —Ü–∏—Ñ—Ä, –Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏ –º–µ–Ω—å—à–µ
    # –ï—Å–ª–∏ —á–∏—Å–ª–æ —Ü–µ–ª–æ–µ –∏ –±–æ–ª—å—à–µ 10^12 (12+ —Ü–∏—Ñ—Ä), –≤–µ—Ä–æ—è—Ç–Ω–æ —ç—Ç–æ –Ω–µ —Å—É–º–º–∞
    if amount == int(amount) and amount >= 1_000_000_000_000:
        return False
    
    return True


async def extract_data_from_excel_table(file_path: str) -> Dict[str, Optional[Union[str, float, int]]]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã Excel
    
    –ò—â–µ—Ç:
    - –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –≤ —Å—Ç–æ–ª–±—Ü–µ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º "–ü–æ—Å—Ç–∞–≤—â–∏–∫", "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å", "–ü—Ä–æ–¥–∞–≤–µ—Ü"
    - –ò—Ç–æ–≥–æ–≤—É—é —Å—É–º–º—É –≤ —Å—Ç–æ–ª–±—Ü–µ "–ò—Ç–æ–≥–æ —Å –ù–î–°", "–ò—Ç–æ–≥–æ", "–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ"
    - –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π —Ç–æ–≤–∞—Ä–∞
    """
    result = {
        "supplier_name": None,
        "total_amount": None,
        "items_count": None
    }
    
    try:
        import openpyxl
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        sheet = workbook.active
        
        # –ò—â–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –≤ –ø–µ—Ä–≤—ã—Ö 10 —Å—Ç—Ä–æ–∫–∞—Ö
        supplier_col = None
        total_col = None
        
        for row_idx in range(1, min(11, sheet.max_row + 1)):
            row = sheet[row_idx]
            for col_idx, cell in enumerate(row, 1):
                cell_value = str(cell.value or '').lower().strip()
                
                # –ò—â–µ–º —Å—Ç–æ–ª–±–µ—Ü —Å –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–º
                if not supplier_col:
                    for marker in SUPPLIER_MARKERS:
                        if marker in cell_value:
                            supplier_col = col_idx
                            break
                
                # –ò—â–µ–º —Å—Ç–æ–ª–±–µ—Ü —Å –∏—Ç–æ–≥–æ–≤–æ–π —Å—É–º–º–æ–π
                if not total_col:
                    for marker in TOTAL_AMOUNT_MARKERS:
                        if marker in cell_value:
                            total_col = col_idx
                            break
            
            # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –æ–±–∞ —Å—Ç–æ–ª–±—Ü–∞, –≤—ã—Ö–æ–¥–∏–º
            if supplier_col and total_col:
                break
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤
        if supplier_col:
            # –ò—â–µ–º –ø–µ—Ä–≤–æ–µ –≤–∞–ª–∏–¥–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –≤ —Å—Ç–æ–ª–±—Ü–µ
            for row_idx in range(2, min(sheet.max_row + 1, 50)):
                cell_value = str(sheet.cell(row=row_idx, column=supplier_col).value or '').strip()
                if cell_value and _is_valid_supplier_name(cell_value):
                    result["supplier_name"] = cell_value[:200]
                    break
        
        if total_col:
            # –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ (–∏—Ç–æ–≥–æ–≤–æ–µ) –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Å—Ç–æ–ª–±—Ü–µ
            # –û–±—ã—á–Ω–æ –∏—Ç–æ–≥–æ–≤–∞—è —Å—É–º–º–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ —Ç–∞–±–ª–∏—Ü—ã
            for row_idx in range(sheet.max_row, max(1, sheet.max_row - 10), -1):
                cell_value = sheet.cell(row=row_idx, column=total_col).value
                if cell_value is not None:
                    try:
                        # –ü—Ä–æ–±—É–µ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ —á–∏—Å–ª–æ
                        if isinstance(cell_value, (int, float)):
                            amount = float(cell_value)
                            if _is_valid_amount(amount):
                                result["total_amount"] = amount
                                break
                        else:
                            # –ï—Å–ª–∏ —ç—Ç–æ —Å—Ç—Ä–æ–∫–∞, –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å —á–∏—Å–ª–æ
                            amount = _extract_amount_from_line_safe(str(cell_value))
                            if amount and _is_valid_amount(amount):
                                result["total_amount"] = amount
                                break
                    except (ValueError, TypeError):
                        continue
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π –∏–∑ Excel
        items_count = await extract_items_count_from_excel(file_path)
        if items_count:
            result["items_count"] = items_count
        
        workbook.close()
        
    except ImportError:
        logger.warning("openpyxl not installed, cannot parse Excel tables")
    except Exception as e:
        logger.error(f"Error extracting data from Excel table: {e}", exc_info=True)
    
    return result


async def extract_cp_data_with_llm(proposal_text: str) -> Dict[str, Optional[Union[str, float, int]]]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ –ö–ü —Å –ø–æ–º–æ—â—å—é LLM (Perplexity)
    
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ fallback –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
    """
    result = {
        "supplier_name": None,
        "total_amount": None,
        "items_count": None
    }
    
    try:
        from services.ai.perplexity import ask_perplexity
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ —Ç–æ–∫–µ–Ω–æ–≤
        text_sample = proposal_text[:3000] if len(proposal_text) > 3000 else proposal_text
        
        prompt = f"""–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–ª–µ–¥—É—é—â–∏–π —Ç–µ–∫—Å—Ç –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è/—Å—á–µ—Ç–∞/–∑–∞–∫–∞–∑–∞ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –∏ –∏–∑–≤–ª–µ–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ.

–¢–µ–∫—Å—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞:
{text_sample}

–ò–∑–≤–ª–µ–∫–∏ —Å–ª–µ–¥—É—é—â—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é:
1. –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ (–∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è) - —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —É–∫–∞–∑–∞–Ω–æ –∫–∞–∫ "–ü–æ—Å—Ç–∞–≤—â–∏–∫", "–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å", "–ü—Ä–æ–¥–∞–≤–µ—Ü"
   –ò–≥–Ω–æ—Ä–∏—Ä—É–π –Ω–∞–∑–≤–∞–Ω–∏—è –±–∞–Ω–∫–æ–≤, –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º, –ª–æ–≥–æ—Ç–∏–ø—ã
   –î–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω—É—é —Ñ–æ—Ä–º—É (–û–û–û, –û–ê–û, –ó–ê–û, –ò–ü, –ü–ê–û)
2. –ò—Ç–æ–≥–æ–≤–∞—è —Å—É–º–º–∞ –∑–∞ —Ç–æ–≤–∞—Ä - –∏—â–∏ –≤ —Å—Ç–æ–ª–±—Ü–µ "–ò—Ç–æ–≥–æ —Å –ù–î–°", "–ò—Ç–æ–≥–æ", "–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ"
   –ú–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∞ —Ü–∏—Ñ—Ä–∞–º–∏ –∏–ª–∏ –ø—Ä–æ–ø–∏—Å—å—é
   –í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–æ (–±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤, —Ç–æ—á–µ–∫, –≤–∞–ª—é—Ç—ã)
3. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π —Ç–æ–≤–∞—Ä–∞ - –∏—â–∏ —Ñ—Ä–∞–∑—ã —Ç–∏–ø–∞ "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π: X", "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–∑–∏—Ü–∏–π: X"
   –ò–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–∏ –ø–æ –ø–æ—Ä—è–¥–∫–æ–≤–æ–º—É –Ω–æ–º–µ—Ä—É –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ç–æ–≤–∞—Ä–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ
   –í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ —á–∏—Å–ª–æ

–û—Ç–≤–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ:
–ü–û–°–¢–ê–í–©–ò–ö: [–Ω–∞–∑–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –∏–ª–∏ "–Ω–µ –Ω–∞–π–¥–µ–Ω"]
–°–£–ú–ú–ê: [—á–∏—Å–ª–æ –∏–ª–∏ "–Ω–µ –Ω–∞–π–¥–µ–Ω–∞"]
–ö–û–õ–ò–ß–ï–°–¢–í–û_–ù–ê–ò–ú–ï–ù–û–í–ê–ù–ò–ô: [—á–∏—Å–ª–æ –∏–ª–∏ "–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ"]

–ï—Å–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, —É–∫–∞–∂–∏ "–Ω–µ –Ω–∞–π–¥–µ–Ω", "–Ω–µ –Ω–∞–π–¥–µ–Ω–∞" –∏–ª–∏ "–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ"."""
        
        response = await ask_perplexity(
            [{"role": "user", "content": prompt}],
            model=None,
            temperature=0.2,
            max_tokens=300
        )
        
        # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç
        for line in response.split('\n'):
            line = line.strip()
            if '–ø–æ—Å—Ç–∞–≤—â–∏–∫:' in line.lower():
                supplier = line.split(':', 1)[1].strip()
                if supplier and supplier.lower() not in ['–Ω–µ –Ω–∞–π–¥–µ–Ω', '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞', '–Ω–µ –Ω–∞–π–¥–µ–Ω.']:
                    result["supplier_name"] = supplier[:200]
            elif '—Å—É–º–º–∞:' in line.lower():
                amount_str = line.split(':', 1)[1].strip()
                if amount_str and amount_str.lower() not in ['–Ω–µ –Ω–∞–π–¥–µ–Ω–∞', '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞.', '–Ω–µ –Ω–∞–π–¥–µ–Ω']:
                    try:
                        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –∫—Ä–æ–º–µ —Ü–∏—Ñ—Ä –∏ —Ç–æ—á–∫–∏/–∑–∞–ø—è—Ç–æ–π
                        amount_clean = re.sub(r'[^\d.,]', '', amount_str.replace(' ', ''))
                        amount_clean = amount_clean.replace(',', '.')
                        if amount_clean:
                            amount = float(amount_clean)
                            if amount >= 100:
                                result["total_amount"] = amount
                    except (ValueError, AttributeError):
                        pass
            elif '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π:' in line.lower() or '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π:' in line.lower():
                count_str = line.split(':', 1)[1].strip()
                if count_str and count_str.lower() not in ['–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ', '–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ.', '–Ω–µ –Ω–∞–π–¥–µ–Ω', '–Ω–µ –Ω–∞–π–¥–µ–Ω–∞']:
                    try:
                        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –∫—Ä–æ–º–µ —Ü–∏—Ñ—Ä
                        count_clean = re.sub(r'[^\d]', '', count_str.replace(' ', ''))
                        if count_clean:
                            count = int(count_clean)
                            if 1 <= count <= 10000:
                                result["items_count"] = count
                    except (ValueError, AttributeError):
                        pass
        
    except Exception as e:
        logger.error(f"Error extracting data with LLM: {e}", exc_info=True)
    
    return result


async def extract_items_count_from_text(text: str) -> Optional[int]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π —Ç–æ–≤–∞—Ä–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞
    
    –ò—â–µ—Ç:
    1. –¢–µ–∫—Å—Ç–æ–≤—ã–µ —É–∫–∞–∑–∞–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π: 5")
    2. –ü–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞ —Ç–æ–≤–∞—Ä–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü–µ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –Ω–æ–º–µ—Ä = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ)
    3. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ —Å —Ç–æ–≤–∞—Ä–∞–º–∏
    
    Args:
        text: –¢–µ–∫—Å—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞
    
    Returns:
        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π –∏–ª–∏ None, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
    """
    if not text:
        return None
    
    text_lower = text.lower()
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ò—â–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —É–∫–∞–∑–∞–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π
    # –£–ª—É—á—à–µ–Ω–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å —É—á–µ—Ç–æ–º —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤: "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π 3", "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π: 3", "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π 3,"
    patterns = [
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å "–≤—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π" - —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        r'–≤—Å–µ–≥–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π[:\s,]+(\d+)',  # "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π 3" –∏–ª–∏ "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π: 3" –∏–ª–∏ "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π 3,"
        r'–≤—Å–µ–≥–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π\s*[:\s,]*\s*(\d+)',  # –ë–æ–ª–µ–µ –≥–∏–±–∫–∏–π –≤–∞—Ä–∏–∞–Ω—Ç
        r'–≤—Å–µ–≥–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π[:\s]*(\d+)',  # –ë–µ–∑ –∑–∞–ø—è—Ç–æ–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–π
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å "–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π"
        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π[:\s,]+(\d+)',
        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π\s*[:\s,]*\s*(\d+)',
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å "–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π –≤—Å–µ–≥–æ"
        r'–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π\s+–≤—Å–µ–≥–æ[:\s,]+(\d+)',
        r'–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π\s+–≤—Å–µ–≥–æ\s*[:\s,]*\s*(\d+)',
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å "–≤—Å–µ–≥–æ –ø–æ–∑–∏—Ü–∏–π"
        r'–≤—Å–µ–≥–æ\s+–ø–æ–∑–∏—Ü–∏–π[:\s,]+(\d+)',
        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+–ø–æ–∑–∏—Ü–∏–π[:\s,]+(\d+)',
        r'–ø–æ–∑–∏—Ü–∏–π\s+–≤—Å–µ–≥–æ[:\s,]+(\d+)',
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å "–≤—Å–µ–≥–æ —Ç–æ–≤–∞—Ä–æ–≤"
        r'–≤—Å–µ–≥–æ\s+—Ç–æ–≤–∞—Ä–æ–≤[:\s,]+(\d+)',
        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+—Ç–æ–≤–∞—Ä–æ–≤[:\s,]+(\d+)',
        r'—Ç–æ–≤–∞—Ä–æ–≤\s+–≤—Å–µ–≥–æ[:\s,]+(\d+)',
        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Å "–≤—Å–µ–≥–æ –µ–¥–∏–Ω–∏—Ü"
        r'–≤—Å–µ–≥–æ\s+–µ–¥–∏–Ω–∏—Ü[:\s,]+(\d+)',
        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+–µ–¥–∏–Ω–∏—Ü[:\s,]+(\d+)',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, text_lower, re.IGNORECASE)
        if match:
            try:
                count = int(match.group(1))
                if 1 <= count <= 10000:  # –†–∞–∑—É–º–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã
                    logger.info(f"Found items count from text pattern '{pattern}': {count}")
                    return count
            except (ValueError, IndexError):
                continue
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ò—â–µ–º –ø–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞ —Ç–æ–≤–∞—Ä–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü–µ
    # –ò—â–µ–º —Å—Ç—Ä–æ–∫–∏ –≤–∏–¥–∞ "1.", "2.", "3." –∏ —Ç.–¥. –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫ (–ø–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞)
    # –ù–æ —Ç–æ–ª—å–∫–æ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Ç–∞–±–ª–∏—Ü—ã —Ç–æ–≤–∞—Ä–æ–≤ (–ø–æ—Å–ª–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞ —Ç–∞–±–ª–∏—Ü—ã)
    lines = text.split('\n')
    max_number = 0
    
    # –ú–∞—Ä–∫–µ—Ä—ã –Ω–∞—á–∞–ª–∞ —Ç–∞–±–ª–∏—Ü—ã —Ç–æ–≤–∞—Ä–æ–≤
    table_start_markers = ['–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ', '—Ç–æ–≤–∞—Ä', '–ø–æ–∑–∏—Ü–∏—è', '–∞—Ä—Ç–∏–∫—É–ª', '–∫–æ–¥', '—Ü–µ–Ω–∞', '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', '—Å—É–º–º–∞', '‚Ññ', '–Ω–æ–º–µ—Ä']
    in_table = False
    
    for line in lines:
        line_stripped = line.strip()
        line_lower = line.lower().strip()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º —Ç–∞–±–ª–∏—Ü—ã
        if any(marker in line_lower for marker in table_start_markers):
            in_table = True
            max_number = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ –Ω–æ–≤–æ–º –∑–∞–≥–æ–ª–æ–≤–∫–µ —Ç–∞–±–ª–∏—Ü—ã
            continue
        
        # –ï—Å–ª–∏ –º—ã –≤ —Ç–∞–±–ª–∏—Ü–µ, –∏—â–µ–º –ø–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞
        if in_table:
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –∏—Ç–æ–≥–∞–º–∏
            if any(word in line_lower for word in ['–∏—Ç–æ–≥–æ', '–≤—Å–µ–≥–æ', '—Å—É–º–º–∞', '---', '===']):
                continue
            
            # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω: —á–∏—Å–ª–æ + —Ç–æ—á–∫–∞/—Å–∫–æ–±–∫–∞ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "1.", "1)", "1 ")
            # –ù–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–∏–∑–Ω–∞–∫–∏ —Ç–æ–≤–∞—Ä–∞ (–±—É–∫–≤—ã, –Ω–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã)
            match = re.match(r'^(\d+)[\.\)\s]+', line_stripped)
            if match:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã (–ø—Ä–∏–∑–Ω–∞–∫ —Ç–æ–≤–∞—Ä–∞)
                if re.search(r'[–∞-—è—ëa-z]', line_lower):
                    try:
                        number = int(match.group(1))
                        if 1 <= number <= 10000:  # –†–∞–∑—É–º–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã
                            max_number = max(max_number, number)
                    except ValueError:
                        continue
    
    if max_number > 0:
        logger.info(f"Found items count from sequential numbers in table: {max_number}")
        return max_number
    
    # –ü–†–ò–û–†–ò–¢–ï–¢ 3: –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ —Å —Ç–æ–≤–∞—Ä–∞–º–∏
    # –ò—â–µ–º —Ç–∞–±–ª–∏—Ü—ã –ø–æ –ø—Ä–∏–∑–Ω–∞–∫–∞–º: –Ω–∞–ª–∏—á–∏–µ —Å—Ç–æ–ª–±—Ü–æ–≤ "–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ", "–¢–æ–≤–∞—Ä", "–ü–æ–∑–∏—Ü–∏—è" –∏ —Ç.–¥.
    table_markers = ['–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ', '—Ç–æ–≤–∞—Ä', '–ø–æ–∑–∏—Ü–∏—è', '–∞—Ä—Ç–∏–∫—É–ª', '–∫–æ–¥', '—Ü–µ–Ω–∞', '–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ', '—Å—É–º–º–∞']
    table_started = False
    table_rows = 0
    
    for line in lines:
        line_lower = line.lower().strip()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º —Ç–∞–±–ª–∏—Ü—ã
        if any(marker in line_lower for marker in table_markers):
            table_started = True
            table_rows = 0
            continue
        
        # –ï—Å–ª–∏ —Ç–∞–±–ª–∏—Ü–∞ –Ω–∞—á–∞–ª–∞—Å—å, —Å—á–∏—Ç–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –¥–∞–Ω–Ω—ã–º–∏
        if table_started:
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç—Ä–æ–∫–∏ —Å –∏—Ç–æ–≥–∞–º–∏
            if not line_stripped or any(word in line_lower for word in ['–∏—Ç–æ–≥–æ', '–≤—Å–µ–≥–æ', '—Å—É–º–º–∞', '---', '===']):
                continue
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Å—Ç—Ä–æ–∫–∞ –¥–∞–Ω–Ω—ã–µ (—Ü–∏—Ñ—Ä—ã, –±—É–∫–≤—ã)
            if re.search(r'[–∞-—è—ëa-z\d]', line_lower):
                table_rows += 1
    
    if table_rows > 0:
        logger.info(f"Found items count from table rows: {table_rows}")
        return table_rows
    
    return None


async def extract_items_count_from_excel(file_path: str) -> Optional[int]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π —Ç–æ–≤–∞—Ä–∞ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã Excel
    
    –ò—â–µ—Ç:
    1. –¢–µ–∫—Å—Ç–æ–≤—ã–µ —É–∫–∞–∑–∞–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤ —è—á–µ–π–∫–∞—Ö
    2. –ü–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞ —Ç–æ–≤–∞—Ä–æ–≤ –≤ –ø–µ—Ä–≤–æ–º —Å—Ç–æ–ª–±—Ü–µ (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –Ω–æ–º–µ—Ä)
    3. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–æ–∫ —Å –¥–∞–Ω–Ω—ã–º–∏ —Ç–æ–≤–∞—Ä–æ–≤
    
    Args:
        file_path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É Excel
    
    Returns:
        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π –∏–ª–∏ None, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
    """
    try:
        import openpyxl
        workbook = openpyxl.load_workbook(file_path, data_only=True)
        sheet = workbook.active
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ò—â–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —É–∫–∞–∑–∞–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤ —è—á–µ–π–∫–∞—Ö
        for row in sheet.iter_rows(values_only=True):
            for cell_value in row:
                if cell_value and isinstance(cell_value, str):
                    cell_lower = cell_value.lower()
                    # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ç–∏–ø–∞ "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π 3", "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π: 3", "–í—Å–µ–≥–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π 3,"
                    patterns = [
                        r'–≤—Å–µ–≥–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π[:\s,]+(\d+)',
                        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π[:\s,]+(\d+)',
                        r'–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π\s+–≤—Å–µ–≥–æ[:\s,]+(\d+)',
                        r'–≤—Å–µ–≥–æ\s+–ø–æ–∑–∏—Ü–∏–π[:\s,]+(\d+)',
                        r'–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\s+–ø–æ–∑–∏—Ü–∏–π[:\s,]+(\d+)',
                    ]
                    for pattern in patterns:
                        match = re.search(pattern, cell_lower)
                        if match:
                            count = int(match.group(1))
                            if 1 <= count <= 10000:
                                workbook.close()
                                logger.info(f"Found items count from Excel cell (pattern '{pattern}'): {count}")
                                return count
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ò—â–µ–º –ø–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞ –≤ –ø–µ—Ä–≤–æ–º —Å—Ç–æ–ª–±—Ü–µ
        max_number = 0
        for row_idx in range(1, min(sheet.max_row + 1, 1000)):  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∏—Å–∫ 1000 —Å—Ç—Ä–æ–∫–∞–º–∏
            cell_value = sheet.cell(row=row_idx, column=1).value
            if cell_value is not None:
                # –ü—Ä–æ–±—É–µ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ —á–∏—Å–ª–æ
                if isinstance(cell_value, (int, float)):
                    number = int(cell_value)
                    if 1 <= number <= 10000:
                        max_number = max(max_number, number)
                elif isinstance(cell_value, str):
                    # –ò—â–µ–º —á–∏—Å–ª–æ –≤ –Ω–∞—á–∞–ª–µ —Å—Ç—Ä–æ–∫–∏
                    match = re.match(r'^(\d+)[\.\)\s]+', cell_value.strip())
                    if match:
                        number = int(match.group(1))
                        if 1 <= number <= 10000:
                            max_number = max(max_number, number)
        
        if max_number > 0:
            workbook.close()
            logger.info(f"Found items count from Excel sequential numbers: {max_number}")
            return max_number
        
        # –ü–†–ò–û–†–ò–¢–ï–¢ 3: –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –¥–∞–Ω–Ω—ã–º–∏ —Ç–æ–≤–∞—Ä–æ–≤
        # –ò—â–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
        header_row = None
        for row_idx in range(1, min(11, sheet.max_row + 1)):
            row = sheet[row_idx]
            row_values = [str(cell.value or '').lower() for cell in row]
            if any(marker in ' '.join(row_values) for marker in ['–Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ', '—Ç–æ–≤–∞—Ä', '–ø–æ–∑–∏—Ü–∏—è', '–∞—Ä—Ç–∏–∫—É–ª']):
                header_row = row_idx
                break
        
        if header_row:
            # –°—á–∏—Ç–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –¥–∞–Ω–Ω—ã–º–∏ –ø–æ—Å–ª–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞
            data_rows = 0
            for row_idx in range(header_row + 1, min(sheet.max_row + 1, header_row + 1000)):
                row = sheet[row_idx]
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–∞–Ω–Ω—ã–µ –≤ —Å—Ç—Ä–æ–∫–µ (–Ω–µ –ø—É—Å—Ç–∞—è)
                has_data = any(cell.value is not None and str(cell.value).strip() for cell in row)
                if has_data:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å –∏—Ç–æ–≥–∞–º–∏
                    row_values_str = ' '.join([str(cell.value or '').lower() for cell in row])
                    if not any(word in row_values_str for word in ['–∏—Ç–æ–≥–æ', '–≤—Å–µ–≥–æ', '—Å—É–º–º–∞']):
                        data_rows += 1
            
            if data_rows > 0:
                workbook.close()
                logger.info(f"Found items count from Excel table rows: {data_rows}")
                return data_rows
        
        workbook.close()
        return None
        
    except ImportError:
        logger.warning("openpyxl not installed, cannot extract items count from Excel")
        return None
    except Exception as e:
        logger.error(f"Error extracting items count from Excel: {e}", exc_info=True)
        return None


async def extract_items_count_combined(
    proposal_text: Optional[str] = None,
    file_path: Optional[str] = None
) -> Optional[int]:
    """
    –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π —Ç–æ–≤–∞—Ä–∞
    
    –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
    1. –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∏–∑ —Ç–∞–±–ª–∏—Ü Excel (–µ—Å–ª–∏ —Ñ–∞–π–ª Excel)
    2. –ó–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
    3. –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ —Ç–∞–±–ª–∏—Ü–∞—Ö
    
    Args:
        proposal_text: –¢–µ–∫—Å—Ç –ö–ü
        file_path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É (–¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ç–∞–±–ª–∏—Ü)
    
    Returns:
        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π –∏–ª–∏ None, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
    """
    # –®–∞–≥ 1: –ü–∞—Ä—Å–∏–º —Ç–∞–±–ª–∏—Ü—ã Excel (–µ—Å–ª–∏ —Ñ–∞–π–ª Excel)
    if file_path:
        file_ext = Path(file_path).suffix.lower()
        if file_ext in {'.xlsx', '.xls'}:
            items_count = await extract_items_count_from_excel(file_path)
            if items_count:
                return items_count
    
    # –®–∞–≥ 2: –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ —Ç–µ–∫—Å—Ç–∞
    if proposal_text:
        items_count = await extract_items_count_from_text(proposal_text)
        if items_count:
            return items_count
    
    return None


async def extract_cp_data_combined(
    proposal_text: str,
    file_path: Optional[str] = None,
    use_llm_fallback: bool = True
) -> Dict[str, Optional[Union[str, float, int]]]:
    """
    –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ö–ü
    
    –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
    1. –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –∏–∑ —Ç–∞–±–ª–∏—Ü Excel (–µ—Å–ª–∏ —Ñ–∞–π–ª Excel)
    2. –ó–∞—Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–µ regex-–ø–∞—Ç—Ç–µ—Ä–Ω—ã
    3. –í –∫–æ–Ω—Ü–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º LLM fallback (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω –∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã)
    
    Args:
        proposal_text: –¢–µ–∫—Å—Ç –ö–ü
        file_path: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É (–¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ç–∞–±–ª–∏—Ü)
        use_llm_fallback: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å LLM –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
    
    Returns:
        –°–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–∞–º–∏: supplier_name, total_amount, items_count
    """
    result = {
        "supplier_name": None,
        "total_amount": None,
        "items_count": None
    }
    
    # –®–∞–≥ 1: –ü–∞—Ä—Å–∏–º —Ç–∞–±–ª–∏—Ü—ã Excel (–µ—Å–ª–∏ —Ñ–∞–π–ª Excel)
    if file_path:
        file_ext = Path(file_path).suffix.lower()
        if file_ext in {'.xlsx', '.xls'}:
            excel_data = await extract_data_from_excel_table(file_path)
            result["supplier_name"] = excel_data.get("supplier_name")
            result["total_amount"] = excel_data.get("total_amount")
            result["items_count"] = excel_data.get("items_count")
    
    # –®–∞–≥ 2: –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ —Ç–µ–∫—Å—Ç–∞ (–µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ —Ç–∞–±–ª–∏—Ü–∞—Ö –∏–ª–∏ –¥–ª—è –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è)
    if proposal_text:
        if not result["supplier_name"]:
            supplier = extract_supplier_name_improved(proposal_text)
            if supplier:
                result["supplier_name"] = supplier
        
        if not result["total_amount"]:
            amount = await extract_total_amount_improved(proposal_text)
            if amount:
                result["total_amount"] = amount
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–π
        if not result["items_count"]:
            items_count = await extract_items_count_combined(proposal_text, file_path)
            if items_count:
                result["items_count"] = items_count
    
    # –®–∞–≥ 3: LLM fallback (–µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –∏ –≤–∫–ª—é—á–µ–Ω fallback)
    if use_llm_fallback and proposal_text:
        if not result["supplier_name"] or not result["total_amount"] or not result["items_count"]:
            llm_data = await extract_cp_data_with_llm(proposal_text)
            
            if not result["supplier_name"] and llm_data.get("supplier_name"):
                result["supplier_name"] = llm_data["supplier_name"]
            
            if not result["total_amount"] and llm_data.get("total_amount"):
                result["total_amount"] = llm_data["total_amount"]
            
            if not result["items_count"] and llm_data.get("items_count"):
                result["items_count"] = llm_data["items_count"]
    
    return result

